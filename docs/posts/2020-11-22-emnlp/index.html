<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Stefan Josef">
<meta name="dcterms.date" content="2020-11-22">

<title>EMNLP 2020 – Stefan’s AI Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-80f6653e4bad1240590acd7234152a3f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Stefan’s AI Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/stefan-jo"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/stefan-josef-7a5a6b120"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">EMNLP 2020</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">nlp</div>
                <div class="quarto-category">conferences</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Stefan Josef </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 22, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="emnlp-2020" class="level1">
<h1>EMNLP 2020</h1>
<p>In this blog post I will describe my experience at the <a href="https://2020.emnlp.org/">2020 Conference on Empirical Methods in Natural Language Processing</a>, that took place virtually between Nov 16 and Nov 20.</p>
<p>It was my first academic ML or NLP conference and I really had a great time. I committed most of my week to the conference and also extended it to the weekend, so that I had two more days to catch up on some papers and talks that I missed during the week. The amount of content that the conference offers in incredible, 752 main conference papers, 25 workshops, 7 tutorials and 5 plenary sessions. Additionally, the conference had plenty of Q&amp;A, gather and demo sessions with paper authors that offer a chance to interact and socialize.</p>
<p>While the information is still fresh, I decided to write down some of my personal highlights from the conference. Of course this only reflects a small subset of the many possibilities. In my role as self-employed NLP data scientist, which necessarily puts me more in the position of a generalist rather than a deeply specialized researcher, I decided to attend as many plenary sessions, tutorials and workshops as possible to get a broad overview of the field and its progress. Even though I’m still relatively new to the field (with a bit more than two years of working in NLP), I could follow along the highly technical content without any problems. I had a somewhat harder time at Q&amp;A and gather sessions, which require detailed knowledge of each discussed topic as well as having read the paper in advance or at least having watched the pre-recorded paper talk. Next time I participate in a virtual conference, I will definitely take a day or two before it starts to better prepare and select the papers I want to learn more about.</p>
<section id="main-conference" class="level2">
<h2 class="anchored" data-anchor-id="main-conference">Main conference</h2>
<p>Of all plenary sessions, which started with a great opening keynote by Claire Cardie from Cornell University on information extraction, my favourite talk was “Friends Don’t Let Friends Deploy Black-Box Models: The Importance of Intelligibility in Machine Learning” by Rich Caruana from Microsoft Research. Even though the talk was actually not about NLP, it was one of the most insightful presentations I experienced at EMNLP.</p>
<p>In his captivating talk, Rich Caruana made the claim that in the 2020s, so-called <em>Glass-Box</em> Machine Learning approaches will take over the world of tabular data. In computer vision and NLP on the other hand, where neural networks most likely will keep the upper hand for quite a while, black-box explainability approaches such as <a href="https://github.com/marcotcr/lime">LIME</a> and <a href="https://github.com/slundberg/shap">SHAP</a> are the best way to go for interpretability. But back to tabular data. While tree-based models, such as Random Forests already have some nice interpretability features (e.g.&nbsp;partial dependence), <em>Glass-Box</em> ML models go much further. The presented <em>Explainable Boosting Machines</em>, or EBMs - part of the family of Generalized Additive Models (GAMs) - are directly interpretable and even editable. Specifically, the functions that EBMs are fitting to single variables or interactions can be inspected visually in the form of graphs. This offers the ability to really explain model behaviour and get valuable insights about the data, which can be invaluable in sensitive domains such as medical applications. Finally, if unwanted patterns are discovered in a graph, the model can be directly edited to avoid making predictions on wrong patterns. All this comes at a comparable performance to gradient-boosting machines or neural networks for tabular data. This could be a real game changer for the world of tabular data. Here is the <a href="https://github.com/interpretml/interpret">repo of InterpretML</a>, which introduces EBMs.</p>
<section id="papers" class="level3">
<h3 class="anchored" data-anchor-id="papers">Papers</h3>
<p>Moving on to EMNLP papers it can be said that Transformer-based models have fully taken over. Among main conference papers, a search for “Transformer” or “BERT” yields 39 and 28 results, respectively, while “LSTM”, “RNN” and “CNN” each only return one search result. Because it’s absolutely impossible to make the right choice picking the <em>best</em> papers from such a huge amount of work, I will just briefly mention a couple of papers that I came across and found particularly interesting. Disclaimer: there is definitely a bias towards dialogue systems, since I recently became interested in that field: - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.326/">Spot The Bot: A Robust and Efficient Framework for the Evaluation of Conversational Dialogue Systems</a> by Deriu et al.&nbsp;won an Honourable Mention Papers award. They introduce a novel method for evaluating chatbots in which humans have to spot which entity is a bot. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.66/">TOD-BERT: Pre-trained Natural Language Understanding for Task-Oriented Dialogue</a> by Wu et al.&nbsp;presents a pre-trained BERT model for task-oriented dialogue that sets new SOTA results for intent classification and response ranking. The pre-trained model has also been open-sourced on the huggingface model hub. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.409/">Probing Task-Oriented Dialogue Representation from Language Models</a> by Wu and Xiong evaluates many language models on various dialogue-related tasks, where ConveRT (see tutorials below), TOD-BERT (above) and TOD-GPT2 achieve the best results. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.273/">MinTL: Minimalist Transfer Learning for Task-Oriented Dialogue Systems</a> by Lin et al.&nbsp;provides a framework for using pre-trained seq2seq models like T5 and BART for dialogue systems especially for low resource settings. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.660/">Universal Natural Language Processing with Limited Annotations: Try Few-shot Textual Entailment as a Start</a> by Yin et al.&nbsp;proposes textual entailment as a universal method for NLP when annotations are insufficient. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.638/">Active Learning for BERT: An Empirical Study</a> by Ein-Dor et al.&nbsp;shows that bringing together transfer learning from pre-trained language models and active learning can help in real-world settings with limited and imbalanced data. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.608/">Which BERT? A Survey Organizing Contextualized Encoders</a> by Xia, Wu and Van Durme is a much needed survey of different BERT models that helps you choose the right approach. - <a href="https://www.aclweb.org/anthology/2020.emnlp-main.369/">The Multilingual Amazon Reviews Corpus</a> by Keung et al.&nbsp;presents a new large-scale corpus of annotated Amazon reviews in multiple languages along with different benchmarks. - <a href="https://www.aclweb.org/anthology/2020.emnlp-demos.6/">Transformers: State-of-the-Art Natural Language Processing</a> by Wolf et al.&nbsp;presents their amazing huggingface libraries and in my opinion deservedly won Best Demo Paper.</p>
</section>
</section>
<section id="tutorials-and-workshops" class="level2">
<h2 class="anchored" data-anchor-id="tutorials-and-workshops">Tutorials and workshops</h2>
<p>In this section I will briefly describe each of the tutorials and workshops I visited at EMNLP 2020. The bottom line is that I can highly recommend each and every one of these high-quality events. I hope some of the talks will be released to the public in the future. Check the EMNLP and ACL sites for updates.</p>
<section id="tutorials" class="level3">
<h3 class="anchored" data-anchor-id="tutorials">Tutorials</h3>
<p><strong>High Performance Natural Language Processing</strong></p>
<p>This tutorial by Gabriel Ilharco, Cesar Ilharco, Iulia Turc, Tim Dettmers, Felipe Ferreira and Kenton Lee was very well prepared and attracted quite some positive attention among the NLP research community on twitter. The tutorial focused on a variety of techniques to make state-of-the-art transformer models more efficient. While large-scale pre-trained NLP models enabled remarkable progress on many benchmarks, the size and resource requirements of these models pose serious problems regarding practical usability, costs and accessability. Starting out with some fundamentals to understand attention and transformers, the tutorial continued explaining different techniques such as knowledge distillation, quantization and pruning. It then went on to look at the large number of recent papers aimed at making the attention mechanism more efficient, such as <a href="https://arxiv.org/abs/2007.14062">Big Bird</a>, <a href="https://arxiv.org/abs/2001.04451">Reformer</a>, <a href="https://arxiv.org/abs/2009.14794">Performer</a> and <a href="https://arxiv.org/abs/1901.02860">Transformer XL</a>. The last part covered the topic of scaling in practice, presenting different opimization techniques and stressing the point that while some optmizations work in theory, in order to really know if they work in practice, you <em>must</em> run them on hardware and see what happens. The slides can be found <a href="http://gabrielilharco.com/publications/EMNLP_2020_Tutorial__High_Performance_NLP.pdf">here</a>.</p>
<p><strong>The Amazing World of Neural Language Generation</strong></p>
<p>The second tutorial I visited covered all topics related to language generation with neural networks. Yangfeng Ji first walked us through a variety of neural network models for text generation, from basic RNNs through Autoencoders and GANs to Transformers. The next two modules by Antoine Bosselut covered decoding and training NLG models. While the first part of his talk presented different kinds of decoding algorithms, such as Beam Search, top-k and top-p sampling, the second part looked at different training techniques, including reinforcement learning and human-in-the-loop learning such as a recent <a href="https://openai.com/blog/learning-to-summarize-with-human-feedback/">summarization technique from Open AI</a>. Then, Asli Celikyilmaz covered the important and challenging topic of evaluating neural text generation models. While human evaluation is certainly the gold-standard, it is also very expensive, time-consuming and sometimes inconsistent. Automatic evaluation can be split into untrained metrics, e.g.&nbsp;distance and overlap and trained metrics, e.g.&nbsp;sentence similartiy or learned human feedback. Interesting benchmarking platforms are <a href="https://parl.ai/">ParlAI</a>, which is a open-source platform for dialogue research and <a href="https://eval.ai/">EvalAI</a>, which supports human-in-the-loop and RL environments. In the final part, Thomas Wolf, CSO at huggingface, went into the challenges when deploying large-scale transformer models. He presented several techniques for optimizing encoders, decoders and decoding algorithms in order to speed up inference. The tutorial slides are available <a href="https://nlg-world.github.io/">here</a>.</p>
<p><strong>Fact-Checking, Fake News, Propaganda, and Media Bias: Truth Seeking in the Post-Truth Era</strong></p>
<p>In this tutorial, Preslav Nakov and Giovanni Da San Martino cover the important topics of disinformation and propaganda. While the title still includes the term “fake news”, Preslav Nakov makes clear early on that we should rather use the term disinformation, which is the overlap of misinformation and malinformation. In other words, disinformation is characterized by falseness and intent to harm. Given the overwhelming amount of news, online discussions and social media posts that are published each day on the internet, using NLP and ML to assist human fact-checkers and/or partially automate the verification process could potentially avoid a lot of harm caused by disinformation campaigns. The tutorial serves both as an introduction to the topic and a presentation of numerous techniques, datasets and challenges. In fact, it covered so much material, that it is impossible to briefly sum up here. But for anyone who is interested in getting started in the field of disinformation I can only recommend to check the <a href="https://drive.google.com/file/d/1GeTZIFW0QPe6zzYZNGF36aFcX955EzYn/view">slides</a>.</p>
</section>
<section id="workshops" class="level3">
<h3 class="anchored" data-anchor-id="workshops">Workshops</h3>
<p><strong>SCAI 2: Search-Oriented Conversational AI</strong></p>
<p>The second <a href="https://scai.info/">SCAI</a> workshop, organized by Julia Kiseleva, Jeff Dalton, Aleksandr Chuklin and Mikhail Burtsev, covered talks and papers related to search-oriented conversational AI. The workshop streamed all pre-recorded talks, followed by live Q&amp;A sessions, to simulate the experience of a live conference. My first highlight was a talk titled “Data-Efficient Natural Language Understanding for Task-Oriented Dialogue”. In his talk, Ivan Vulić from <a href="https://www.polyai.com/">PolyAI</a> addressed the idea of using pre-trained models that encode conversational knowledge to reduce the need for annotated data for building dialogue systems. <a href="https://www.aclweb.org/anthology/2020.findings-emnlp.196/">ConveRT</a>, which also was a findings paper at EMNLP 2020, uses response selection from large <a href="https://github.com/PolyAI-LDN/conversational-datasets">conversational datasets</a> as pre-training task. The compact Transformer-based model can be fine-tuned on CPUs and achieves great results on response selection and intent classification. My other highlight was <a href="https://arxiv.org/abs/2004.13637">BlenderBot</a>, presented by Jason Weston from Facebook AI Research. The paper presents a recipe for building open-domain chatbots based on large-scale pre-training of Transformer models, fine-tuning and inference optimization. While BlenderBot outperformed Google’s <a href="https://arxiv.org/abs/2001.09977">Meena</a> and achieved near-human performance on some tasks, the authors stress that these results should be taken with a grain of salt and the model still makes many typical mistakes such as repetition, inconsistencies or factual incorrectness.</p>
<p><strong>SustaiNLP: Workshop on Simple and Efficient Natural Language Processing</strong></p>
<p>I’ve really been looking forward to <a href="https://sites.google.com/view/sustainlp2020/home">SustaiNLP</a> and it also was one of the main reasons why I considered attending EMNLP this year. Concerned by the complexity and resource requirements of recent large-scale Transformer models, the workshop’s goal was to promote “simpler and more sustainable NLP research and practices”. My favourite talk at the workshop was “Making Pre-trained Models More Sustainable” by Armand Joulin. The talk starts with the premise that the only thing we know for sure is that we want to simplify pre-trained models - even if we don’t know how exactly in advance. Based on this idea, Transformer models can actually be prepared during pre-training to better deal with simplifications during fine-tuning. A way to do this is to apply structured layer dropout during pre-training, which forces the model to spread out its knowledge more evenly across all layers. When the model size is then reduced at the fine-tuning stage, the model already “knows” how to perform well with a subset of its layers.</p>
<p>Two papers that I would recommend from the workshop are <a href="https://www.aclweb.org/anthology/2020.sustainlp-1.17/">SqueezeBERT</a> by Iandola et al., which leverages ideas from computer vision in order to speed up BERT on mobile devices, and <a href="https://www.aclweb.org/anthology/2020.sustainlp-1.20/">FastFormers</a> by Young Jin Kim and Hany Hassan, which combines distillation, pruning, quantization and runtime optimization to achieve a 233x speedup of BERT-base on CPU at less than a 2% drop in accuracy.</p>
</section>
</section>
<section id="concluding-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="concluding-thoughts">Concluding thoughts</h2>
<p>I still need some time to process all the new information that I got during the last seven days and I have many papers marked that I still want to read, but all in all I can already now say that I learned <em>a lot</em>. I can only recommend to participate in conferences like this even if you’re (like me) not an experienced NLP researcher. Participating in conferences like EMNLP gives you the unique opportunity to get a detailed impression where the field currently is and look at cutting-edge research from a front row seat. Apart from the already mentioned fact that I want to better prepare in advance for my next conference, my other lesson learned is that I want to set aside more time during the conference to engage socially, make new contacts and exchange ideas.</p>
<p>I also want to say that the concept of a virtual conference really resonates with me. Of course it lacks the personal experience of physically being in a room together with others, but on the other hand it allows people from all over the world to attend top conferences at a much lower cost. I really hope that hybrid-style conferences with both personal attendance and virtual experience will be offered in the future.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>